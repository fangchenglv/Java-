# OSI分层模型
## 1 应用层
### &emsp;&emsp;在互联网中应用层协议很多，如域名系统DNS，支持万维网应用的 HTTP协议，支持电子邮件的 SMTP协议等等。我们把应用层交互的数据单元称为报文。
## 2 运输层
### &emsp;&emsp;传输控制协议 TCP（Transmisson Control Protocol）—— 提供面向连接的，可靠的数据传输服务。
### &emsp;&emsp;用户数据协议 UDP（User Datagram Protocol）—— 提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。

## 3 网络层
	在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报 ，简称数据报。
## 4 数据链路层

## 5 物理层

#					
# TCP、UDP的特点

## UDP 的主要特点
	UDP 是无连接的；
	UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）；
	UDP 是面向报文的；
	UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 直播，实时视频会议等）；
	UDP 支持一对一、一对多、多对一和多对多的交互通信；
	UDP 的首部开销小，只有8个字节，比TCP的20个字节的首部要短。

## TCP 的主要特点
	TCP 是面向连接的。（就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接）；
	每一条 TCP 连接只能有两个端点，每一条TCP连接只能是点对点的（一对一）；
	TCP 提供可靠交付的服务。通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达；
	TCP 提供全双工通信。TCP 允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据；
	面向字节流。TCP 中的“流”（Stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。		
					
							
#
# TCP 三次握手和四次挥手

## 为什么要三次握手
---
###	&emsp;&emsp;三次握手的目的是建立可靠的通信信道，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。
	
###	&emsp;&emsp;第一次握手：Client 什么都不能确认；Server 确认了对方发送正常
	
###	&emsp;&emsp;第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己接收正常，对方发送正常
	
###	&emsp;&emsp;第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送接收正常
	
###	&emsp;&emsp;所以三次握手就能确认双发收发功能都正常，缺一不可。
---
## 关于TCP三次握手？二次握手为什么不行？
---
### &emsp;&emsp;建立连接的过程是利用客户服务器模式，假设主机A为客户端，主机B为服务器端。
### &emsp;&emsp;采用三次握手是为了防止失效的连接请求报文段突然又传送到主机B，因而产生错误。失效的连接请求报文段是指：主机A发出的连接请求没有收到主机B的确认，于是经过一段时间后，主机A又重新向主机B发送连接请求，且建立成功，顺序完成数据传输。考虑这样一种特殊情况，主机A第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机B，主机B以为是主机A又发起的新连接，于是主机B同意连接，并向主机A发回确认，但是此时主机A根本不会理会，主机B就一直在等待主机A发送数据，导致主机B的资源浪费。
	
	谢希仁版《计算机网络》中的例子:
	"已失效的连接请求报文段”的产生在这样一种情况下：
	client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。
	本来这是一个早已失效的报文段,但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。
	于是就向client发出确认报文段，同意建立连接。
	假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。
	由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据,但server却以为新的运输连接已经建立，并一直等待client发来数据。
	这样，server的很多资源就白白浪费掉了
	采用“三次握手”的办法可以防止上述现象发生
---
## 为什么要四次挥手
---
### 全双工通信。  任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。
	关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，
	所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。
	只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。
	故需要四步握手。
	挥手次数比握手多一次，是因为握手过程，通信只需要处理连接。而挥手过程，通信需要处理数据+连接。

---
## 全连接队列与半连接队列
---
在握手阶段存在两个队列：   
- 全连接队列(accept queue)  
- 半连接队列(syns queue)  
### 解析：当第一次握手(client客户端的SYN到达server服务端时)TCP会在未完成连接队列中创建一个新项，这一项会一直保留在未完成连接队列中直到第三次握手(客户对服务器SYN的ACK)结束为止。如果三次握手全部正常完成，该项则会从未完成连接队列移到已完成连接队列的队尾。当进程调用accept()时，已完成连接队列中的队头项将返回给进程。
#
# TCP、UDP 协议的区别
### &emsp;&emsp;UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等

### &emsp;&emsp;TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的运输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。
#
# TCP 协议如何保证可靠传输
### &emsp;&emsp;应用数据被分割成 TCP 认为最适合发送的数据块。TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。
- ### 校验和： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。
- ### 流量控制： TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）
- ### 拥塞控制： 当网络拥塞时，减少数据的发送。慢开始 、 拥塞避免 、快重传 和 快恢复
- ### 停止等待协议 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。
- ### 超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。
#
# 拥塞控制
### &emsp;&emsp;为了进行拥塞控制，TCP 发送方要维持一个 拥塞窗口(cwnd) 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。
### &emsp;&emsp;TCP的拥塞控制采用了四种算法，即 慢开始 、 拥塞避免 、快重传 和 快恢复。
- ### 慢开始：
		慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。
- ### 拥塞避免：
		 拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送方的cwnd加1。
- ### 快重传与快恢复：
		在 TCP/IP 中，快速重传和恢复是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。
#
# TCP粘包和拆包
## 发生TCP粘包、拆包主要是由于下面一些原因：
	应用程序写入的数据大于套接字缓冲区大小，这将会发生拆包。
	应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包。
	进行mss（最大报文长度）大小的TCP分段，当TCP报文长度-TCP头部长度>mss的时候将发生拆包。
## 解决粘包。
	使用带消息头的协议、消息头存储消息开始标识及消息长度信息，服务端获取消息头的时候解析出消息长度，然后向后读取该长度的内容。
	设置定长消息，服务端每次读取既定长度的内容作为一条完整消息。
	设置消息边界，服务端从网络流中按消息编辑分离出消息内容。
#		
# time_wait状态如何产生？ 

	由上面的变迁图，首先调用close()发起主动关闭的一方，在发送最后一个ACK之后会进入time_wait的状态，也就说该发送方会保持2MSL时间之后才会回到初始状态。MSL值得是数据包在网络中的最大生存时间。产生这种结果使得这个TCP连接在2MSL连接等待期间，定义这个连接的四元组（客户端IP地址和端口，服务端IP地址和端口号）不能被使用
	2.time_wait状态产生的原因
	1）为实现TCP全双工连接的可靠释放
	2）为使旧的数据包在网络因过期而消失


## 解决TIME_AWAIT过多方案
	相关参数优化调整（当然得根据服务器的实际情况配置）
	调整TIME_WAIT_2到TIME_WAIT的超时时间，默认是60s，优化到30s


# RPC和http的区别是什么，有什么优缺点
## 1.首先介绍一下http和rpc
http：是指从客户端到服务端的请求消息
rpc：是远程过程调用协议
## 2.区别

### 2.1：http协议
#### &emsp;&emsp;http请求是使用具有标准定义的通用的接口定向到资源，这些语义能够被中间组件和提供服务的来源机器进行解释。这样会使得一个应用支持分层的转换和间接，并且独立于消息的来，这对于一个internet规，多个组，无法控制的可伸缩的信息系统来，是非常有用的。  
#### &emsp;&emsp;rpc的机制是根据语言的API来定义，而不是根据基于网络的应用来定义的。

## 3.优缺点
### 3.1 传输协议  
	rpc:可以基于TCP协，也可以基于HTTP协议&#xff1b  
	HTTP:基于HTTP协议
### 3.2 传输效率  
	rpc使用自定义的TCP协，可以让请求报文体积更，或者使用HTTP2协，也可以很好的减少报文的体，提高传输效率。
	http如果是基于HTTP1.1的协，请求中会包含很多无用的内，如果是基于HTTP2.0的协，那么简单的封装一下是可以作为一个RPC来使用，这时标准RPC框架更多的是服务治理。
### 3.3 性能消耗  
	rpc可以基于thrift实现高效的二进制传输
	http大部分是通过json来实现的，字节大小和序列化耗时都比thrift要更消耗性能  
### 3.4  负载均衡  
	rpc基本都自带负载均衡策略
	http需要配置Ngin，HAProxy来实现  
### 3.5 服务治理  
	rpc能做到自动通，不影响上游  
	http需要事先通，修改Ngin，HAProxy配置
	总的来，RPC主要用于公司内部的服务调，性能消耗，传输效率，服务质量方便。    
	http主要用于对外的异构环，浏览器接口调，app接口调，第三方接口调用等  