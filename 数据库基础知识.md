

mysql索引、B+树   叶子节点存信息，叶子节点双向链表

B树比平衡树减少IO次数，B+树比B树多范围查找，减少IO次数

	回表：先定位主键值，再定位记录，扫描两遍索引
	聚集索引，叶子节点存储行记录；
	普通索引，叶子节点存储PK值。

索引覆盖
	只需要在一棵索引树上就能获取SQL所需的所有列数据，无需回表，速度更快。
如何实现索引覆盖
	常见的方法是：将被查询的字段，建立到联合索引里去。
MySQL聚集索引和非聚集索引
聚集索引
索引中键值的逻辑顺序决定了表中相应行的物理顺序。
聚集索引确定表中数据的物理顺序。聚集索引类似于电话簿，后者按姓氏排列数据。 聚集索引对于那些经常要搜索范围值的列特别有效。使用聚集索引找到包含第一个值的行后，便可以确保包含后续索引值的行在物理相邻。

非聚集索引
索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同。
非聚集索引的存储结构与前面是一样的，不同的是在叶子结点的数据部分存的不再是具体的数据，而数据的聚集索引的key。所以通过非聚集索引查找的过程是先找到该索引key对应的聚集索引的key，然后再拿聚集索引的key到主键索引树上查找对应的数据，这个过程称为回表！

一、索引种类
	普通索引：仅加速查询
	唯一索引：加速查询 + 列值唯一（可以有null）
	主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个
	组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并
	全文索引：对文本的内容进行分词，进行搜索


二、建立索引的原则：
	定义主键的数据列一定要建立索引。
	定义有外键的数据列一定要建立索引。
	对于经常查询的数据列最好建立索引。
	对于需要在指定范围内的快速或频繁查询的数据列;
	经常用在WHERE子句中的数据列。
	经常出现在关键字order by、group by、distinct后面的字段，建立索引。如果建立的是复合索引，索引的字段顺序要和这些关键字后面的字段顺序一致，否则索引不会被使用。
	对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。
	对于定义为text、image和bit的数据类型的列不要建立索引。
	对于经常存取的列避免建立索引
	限制表上的索引数目。对一个存在大量更新操作的表，所建索引的数目一般不要超过3个，最多不要超过5个。索引虽说提高了访问速度，但太多索引会影响数据的更新操作。
	对复合索引，按照字段在查询条件中出现的频度建立索引。在复合索引中，记录首先按照第一个字段排序。对于在第一个字段上取值相同的记录，系统再按照第二个字段的取值排序，以此类推。因此只有复合索引的第一个字段出现在查询条件中，该索引才可能被使用,因此将应用频度高的字段，放置在复合索引的前面，会使系统最大可能地使用此索引，发挥索引的作用。

	MySQL InnoDB 默认行级锁。行级锁都是基于索引的，如果一条 SQL 语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住，这点需要注意。
	
	联合索引：
	建立联合索引create index 索引名 on 表名(column_1, column_2, column_3);
	(column_2,column_3)这样的查询命中不到索引
	
	最左匹配原则：和b+树存储结构相关，查询次数多的放左边
	
	EXPLAIN查看执行计划 分析查询效率
	
						
	
	索引无效情况：
	1、如果条件中有 or ，即使其中有条件带索引也不会使用  除非将or条件中的每个列都加上索引
	2、like查询是以%开头，索引不会命中
	3、如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引
	4. 没有查询条件，或者查询条件没有建立索引
	5. 查询条件中，在索引列上使用函数（+, - ,*,/）, 这种情况下需建立函数索引
	6. 采用 not in, not exist
	7. B-tree 索引 is null 不会走， is not null 会走
	8、where字句中使用方法
	
事务
	构成事务的所有操作,要么全都对数据库产生影响,要么全都不产生影响,即不
	管事务是否执行成功,数据库总能保持一致性状态。
	事务有ACID特性
	原子性(Atomicity)
	一致性(Consistency):事务的执行结果必须使数据库从一个一致性状态到另一个一致性状态。
	隔离性(Isolation):并发执行的事务不会相互影响
	持久性(Durability):
	
事务的实现
	前面讲的重做日志，回滚日志以及锁技术就是实现事务的基础。
	事务的原子性是通过 undo log 来实现的
	事务的持久性性是通过 redo log 来实现的
	事务的隔离性是通过 (读写锁+MVCC)来实现的
	而事务的终极大 boss 一致性是通过原子性，持久性，隔离性来实现的！！！
	原子性，持久性，隔离性折腾半天的目的也是为了保障数据的一致性！
	
事务的隔离级别：

	  读未提交(READ UNCOMMITTED)
	  读已提交(READ COMMITTED)
	  可重复读(REPEATABLE READ)
	  串行化(SERIALIZABLE)

脏读
	脏读是指当一个事务正在访问数据，并且对数据进行了修改。而这种修改还没有提交到数据库中，这时，另外一个事务也访问了这个数据，然后使用了这个数据。
幻读
	幻读是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到了表中的全部数据行。同时，第二个事务也修改了这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好像发生了幻觉一样。
不可重复读
	不可重复读是指一个事务内多次根据同一查询条件查询出来的同一行记录的值不一致。

         隔离级别	    	脏读	不可重复读	幻读
READ UNCOMMITED (读未提交)	允许	允许	允许
READ COMMITED (读已提交)	 不允许  	 允许	 允许
REPEATABLE READ (可重复读)（默认隔离级别）	不允许	不允许	允许
SERIALIZABLE (串行化)	不允许	不允许	不允许

							

mysql在可重复读隔离级别下怎么解决幻读
	MySQL的Gap锁
	MySQL的共享锁(读锁)和排它锁（写锁）大家应该都比较熟悉了，那gap锁是什么东西呢？
	
	1. select *from user where age>0 and age<10 for update;
	2. 或者
	3. select *from user where age>0 and age<10;
	4. 或者
	5. select *from user where age>0 and age<10 in share mode;
	举个栗子，我们在一个事务中执行上述的SQL语句,数据库中只有age=1，age=4，age=7，age=8 这三条满足条件的记录,那么gap锁会加到age=2，3，5，6，9上面，如果另外一个事务里面想insert age=2，3，5，6，9 是会被阻塞的，因为第一个事务拿到了gap锁。
	
临键锁(next-key)。根据索引，划分为一个个左开右闭的区间。当进行范围查询的时候，若命中索引且能够检索到数据，则锁住记录所在的区间和它的下一个区间
	 
	MySql中如果是快照读，那么是通过MVCC(多版本控制)来避免幻读.
	如果是当前读，那么是通过gap锁来避免幻读
	• 排它锁解决脏读
	• 共享锁解决不可重复读
	• 临键锁解决幻读

1.1 什么是MVCC
		MVCC是一种多版本并发控制机制。
	1.2 MVCC是为了解决什么问题?
		大多数的MYSQL事务型存储引擎,如,InnoDB不使用一种简单的行锁机制。他们都和MVCC–多版本并发控制来一起使用。
		大家都应该知道,锁机制可以控制并发操作,但是其系统开销较大,而MVCC可以在大多数情况下代替行级锁,使用MVCC,能降低其系统开销.
	1.3 MVCC实现
		MVCC是通过保存数据在某个时间点的快照来实现的. 不同存储引擎的MVCC. 不同存储引擎的MVCC实现是不同的,典型的有乐观并发控制和悲观并发控制。
	2.MVCC 具体实现分析
		InnoDB的MVCC,是通过在每行记录后面保存两个隐藏的列来实现的,这两个列，分别保存了系统版本号(可以理解为事务的ID)，每开始一个新的事务，系统版本号就会自动递增，事务开始时刻的系统版本号会作为事务的ID。
		
		不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作。
	
一、MySQL常用存储引擎及特点
1、InnoDB存储引擎
	从MySQL5.5版本之后，MySQL的默认内置存储引擎已经是InnoDB了，他的主要特点有：
	（1）灾难恢复性比较好；
	（2）支持事务。默认的事务隔离级别为可重复读。
	（3）使用的锁粒度为行级锁，可以支持更高的并发；
	（4）支持外键；
	（5）在InnoDB中存在着缓冲管理，通过缓冲池，将索引和数据全部缓存起来，加快查询的速度；
	（6）配合一些热备工具可以支持在线热备份；
	（7）对于InnoDB类型的表，其数据的物理组织形式是聚簇表。所有的数据按照主键来组织。数据和索引放在一块，都位于B+树的叶子节点上；
2、MyISAM存储引擎
	在5.5版本之前，MyISAM是MySQL的默认存储引擎，该存储引擎并发性差，不支持事务，所以使用场景比较少，主要特点为：
	（1）不支持事务；
	（2）不支持外键，如果强行增加外键，不会提示错误，只是外键不其作用；
	（3）对数据的查询缓存只会缓存索引，不会像InnoDB一样缓存数据，而且是利用操作系统本身的缓存；
	（4）默认的锁粒度为表级锁，所以并发度很差，加锁快，锁冲突较少，所以不太容易发生死锁；
	（5）支持全文索引（MySQL5.6之后，InnoDB存储引擎也对全文索引做了支持），但是MySQL的全文索引基本不会使用，对于全文索引，现在有其他成熟的解决方案，比如：ElasticSearch，Solr，Sphinx等。
	（6）数据库所在主机如果宕机，MyISAM的数据文件容易损坏，而且难恢复；
3、MEMORY存储引擎
	将数据存在内存中，和市场上的Redis，memcached等思想类似，为了提高数据的访问速度，主要特点：
	（1）支持的数据类型有限制，比如：不支持TEXT和BLOB类型，对于字符串类型的数据，只支持固定长度的行，VARCHAR会被自动存储为CHAR类型；
	（2）支持的锁粒度为表级锁。所以，在访问量比较大时，表级锁会成为MEMORY存储引擎的瓶颈；
	（3）由于数据是存放在内存中，所以在服务器重启之后，所有数据都会丢失；
	（4）查询的时候，如果有用到临时表，而且临时表中有BLOB，TEXT类型的字段，那么这个临时表就会转化为MyISAM类型的表，性能会急剧降低；
4、ARCHIVE存储引擎
	ARCHIVE存储引擎适合的场景有限，由于其支持压缩，故主要是用来做日志，流水等数据的归档，主要特点：
	（1）支持Zlib压缩，数据在插入表之前，会先被压缩；
	（2）仅支持SELECT和INSERT操作，存入的数据就只能查询，不能做修改和删除；
	（3）只支持自增键上的索引，不支持其他索引；

5、CSV存储引擎
	数据中转试用，主要特点：
	（1）其数据格式为.csv格式的文本，可以直接编辑保存；
	（2）导入导出比较方便，可以将某个表中的数据直接导出为csv，试用Excel办公软件打开；

二、InnoDB和MyISAM的对比
	1、由于锁粒度的不同，InnoDB比MyISAM支持更高的并发；
	2、InnoDB为行级锁，MyISAM为表级锁，所以InnoDB相对于MyISAM来说，更容易发生死锁，锁冲突的概率更大，而且上锁的开销也更大，因为需要为每一行加锁；
	3、在备份容灾上，InnoDB支持在线热备，有很成熟的在线热备解决方案；
	4、查询性能上，MyISAM的查询效率高于InnoDB，因为InnoDB在查询过程中，是需要维护数据缓存，而且查询过程是先定位到行所在的数据块，然后在从数据块中定位到要查找的行；而MyISAM可以直接定位到数据所在的内存地址，可以直接找到数据；
	5、SELECT COUNT(*)语句，如果行数在千万级别以上，MyISAM可以快速查出，而InnoDB查询的特别慢，因为MyISAM将行数单独存储了，而InnoDB需要朱行去统计行数；所以如果使用InnoDB，而且需要查询行数，则需要对行数进行特殊处理，如：离线查询并缓存；
	6、MyISAM的表结构文件包括：.frm(表结构定义),.MYI(索引),.MYD(数据)；而InnoDB的表数据文件为:.ibd和.frm(表结构定义)；


	InnoDB: 其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”。而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，在走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。
	只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！
	在不通过索引条件查询的时候，InnoDB确实使用的是表锁，而不是行锁。

	MyISAM: B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。

MyISAM和InnoDB存储引擎使用的锁：

	MyISAM采用表级锁(table-level locking)。InnoDB支持行级锁(row-level locking)和表级锁,默认为行级锁

表级锁和行级锁对比：

	表级锁： Mysql中锁定粒度最大的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。

	行级锁： Mysql中锁定粒度最小的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。
	
	


三、如何选择合适的存储引擎
	1、使用场景是否需要事务支持；
	2、是否需要支持高并发，InnoDB的并发度远高于MyISAM；
	3、是否需要支持外键；
	4、是否需要支持在线热备；
	5、高效缓冲数据，InnoDB对数据和索引都做了缓冲，而MyISAM只缓冲了索引；
	6、索引，不同存储引擎的索引并不太一样；


七、大表优化
当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：
	限定数据的范围： 务必禁止不带任何限制数据范围条件的查询语句。
	读/写分离： 经典的数据库拆分方案，主库负责写，从库负责读；
	缓存： 使用MySQL的缓存，另外对重量级、更新少的数据可以考虑使用应用级别的缓存；
	垂直分区：
		根据数据库里面数据表的相关性进行拆分。 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。
	直拆分的优点：
		可以使得行数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。
	垂直拆分的缺点： 
		主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；
           水平分区：
		保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。
		水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。
		水品拆分可以支持非常大的数据量。
		需要注意的一点是:分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL 并发能力没有什么意义，所以 水品拆分最好分库 。
		水平拆分能够 支持非常大的数据量存储，应用端改造也少，但 分片事务难以解决 ，跨界点Join 性能较差，逻辑复杂。
		
“慢查询”
分析MySQL语句查询性能的方法除了使用 EXPLAIN 输出执行计划，还可以让MySQL记录下查询超过指定时间的语句，我们将超过指定时间的
	SQL语句查询称为“慢查询”。


数据库连接池：目前常用的连接池有：C3P0、DBCP、Proxool

	c3p0与dbcp区别
		a. dbcp默认不自动回收空闲连接，需要手动开启
		b. c3p0默认自动回收空闲连接功能

 JdbcPool.java:
大致思路：1、读取配置文件，将属性值取出

                   2、注册jdbc驱动

                   3、通过数据库连接数和驱动管理器获得相应连接（.getConnection()）,因为DataSource是接口，所以这个方法需要我们手动实现

                   4、重点：实现getConnection()方法

如何保证缓存和数据库的一致性
	延时双删策略

4.什么是存储过程？用什么来调用？
	存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。
	调用：
	1）可以用一个命令对象来调用存储过程。
	2）可以供外部程序调用，比如：java程序。
5.存储过程的优缺点？
	优点：
	1）存储过程是预编译过的，执行效率高。
	2）存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。
	3）安全性高，执行存储过程需要有一定权限的用户。
	4）存储过程可以重复使用，可减少数据库开发人员的工作量。
	缺点：移植性差

11、读写分离：
主数据库负责处理写操作（当然也可以执行读操作），从数据库负责处理读操作，不能执行写操作。

## 数据库基础知识

### replace into 用法
根据唯一主键判定，存在的删除之后添加，不存在的直接添加


### 索引



---
|  事务A   | 事务B  | 备注  |
|  :----:  | :----:  |:----:  |
| select name from t_test where id=1  |  |结果：majunlei  |
|   | update t_test set name="majunlei2" where id=1 | |
| select name from t_test where id=1  |  |结果：majunlei2  |

---
在同一个事务中，查询到的结果却不一样，即为“不可重复读”



---
|  事务A   | 事务B  | 备注  |
|  :----:  | :----:  |:----:  |
| update t_test set name="majunlei_new"  |  | |
|   | insert into t_test(id,name) values(2,"majunlei2") where id=1 | |
| select name from t_test  |  |结果：majunlei_new,majunlei2  |

---
事务A明明更新了全部的记录，却有一条不是更新后的结果，像出现了幻觉一样，即为“幻读”。

锁
S锁（读锁）、X锁（写锁）
MVCC
gap锁，顾名思义，间隙锁，不同于锁住某些特定的记录，gap锁锁住的是一段“间隙”。gap锁可以认为是RR级别特有的一种锁。

由于唯一索引能唯一地确定一条记录，因此不考虑范围查询的情况下，gap锁只有在非唯一索引时才会产生。如果有范围查询，则gap锁在整个查询范围都会存在。

gap锁+record锁（记录锁）即为next key锁。gap锁与gap锁相容，但next key锁与next key锁冲突。


# 详细分析MySQL事务日志(redo log和undo log)

https://www.cnblogs.com/f-ck-need-u/archive/2018/05/08/9010872.html

innodb事务日志包括redo log和undo log。redo log是重做日志，提供前滚操作，undo log是回滚日志，提供回滚操作。

undo log不是redo log的逆向过程，其实它们都算是用来恢复的日志：
1.redo log通常是物理日志，记录的是数据页的物理修改，而不是某一行或某几行修改成怎样怎样，它用来恢复提交后的物理数据页(恢复数据页，且只能恢复到最后一次提交的位置)。
2.undo用来回滚行记录到某个版本。undo log一般是逻辑日志，根据每行记录进行记录。
1.redo log

1.1 redo log和二进制日志的区别

redo log不是二进制日志。虽然二进制日志中也记录了innodb表的很多操作，也能实现重做的功能，但是它们之间有很大区别。

1、二进制日志是在存储引擎的上层产生的，不管是什么存储引擎，对数据库进行了修改都会产生二进制日志。而redo log是innodb层产生的，只记录该存储引擎中表的修改。并且二进制日志先于redo log被记录。具体的见后文group commit小结。
2、二进制日志记录操作的方法是逻辑性的语句。即便它是基于行格式的记录方式，其本质也还是逻辑的SQL设置，如该行记录的每列的值是多少。而redo log是在物理格式上的日志，它记录的是数据库中每个页的修改。

1.2 redo log的基本概念
redo log包括两部分：一是内存中的日志缓冲(redo log buffer)，该部分日志是易失性的；二是磁盘上的重做日志文件(redo log file)，该部分日志是持久的。

在概念上，innodb通过force log at commit机制实现事务的持久性，即在事务提交的时候，必须先将该事务的所有事务日志写入到磁盘上的redo log file和undo log file中进行持久化。

![image](https://images2018.cnblogs.com/blog/733013/201805/733013-20180508101949424-938931340.png)

MySQL支持用户自定义在commit时如何将log buffer中的日志刷log file中。这种控制通过变量 innodb_flush_log_at_trx_commit 的值来决定。该变量有3种值：0、1、2，默认为1。但注意，这个变量只是控制commit动作是否刷新log buffer到磁盘。

当设置为1的时候，事务每次提交都会将log buffer中的日志写入os buffer并调用fsync()刷到log file on disk中。这种方式即使系统崩溃也不会丢失任何数据，但是因为每次提交都写入磁盘，IO的性能较差。
当设置为0的时候，事务提交时不会将log buffer中日志写入到os buffer，而是每秒写入os buffer并调用fsync()写入到log file on disk中。也就是说设置为0时是(大约)每秒刷新写入到磁盘中的，当系统崩溃，会丢失1秒钟的数据。
当设置为2的时候，每次提交都仅写入到os buffer，然后是每秒调用fsync()将os buffer中的日志写入到log file on disk。

![image](https://images2018.cnblogs.com/blog/733013/201805/733013-20180508104623183-690986409.png)   
更好的插入数据的做法是将值设置为1，然后修改存储过程，将每次循环都提交修改为只提交一次


2.undo log

2.1 基本概念
undo log有两个作用：提供回滚和多个行版本控制(MVCC)。

在数据修改的时候，不仅记录了redo，还记录了相对应的undo，如果因为某些原因导致事务失败或回滚了，可以借助该undo进行回滚。

undo log和redo log记录物理日志不一样，它是逻辑日志。可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。

当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。有时候应用到行版本控制的时候，也是通过undo log来实现的：当读取的某一行被其他事务锁定时，它可以从undo log中分析出该行记录以前的数据是什么，从而提供该行版本信息，让用户实现非锁定一致性读取。

undo log是采用段(segment)的方式来记录的，每个undo操作在记录的时候占用一个undo log segment。

另外，undo log也会产生redo log，因为undo log也要实现持久性保护。


一、重做日志（redo log）
作用：
确保事务的持久性。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性。

二、回滚日志（undo log）
作用：
保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读

三、二进制日志（binlog）：
作用：
用于复制，在主从复制中，从库利用主库上的binlog进行重播，实现主从同步。 
用于数据库的基于时间点的还原。

# MySQL主从复制（异步复制与半同步复制）

https://blog.csdn.net/keil_wang/article/details/88669587

MySQL主从复制
![image](https://img2018.cnblogs.com/blog/1606768/201904/1606768-20190408141304873-785770801.png)
原理：将主服务器的binlog日志复制到从服务器上执行一遍，达到主从数据的一致状态。

过程：从库开启一个I/O线程，向主库请求Binlog日志。主节点开启一个binlog dump线程，检查自己的二进制日志，并发送给从节点；从库将接收到的数据保存到中继日志（Relay log）中，另外开启一个SQL线程，把Relay中的操作在自身机器上执行一遍

优点：

作为备用数据库，并且不影响业务
可做读写分离，**一般是一个写主库，一个或多个读从库**，分布在不同的服务器上，充分发挥服务器和数据库的性能，但要保证数据的一致性
扩展：

SQL线程执行完Relay log中的事件后，会将当前的中继日志Relay log删除，避免它占用更多的磁盘空间
为保证从库重启后，仍然知道从哪里开始复制，从库默认会创建两个文件master.info和relay-log.info，分别记录了从库的IO线程当前读取主库binlog的进度和SQL线程应用Relay-log的进度。可通过show slave status \G命令查看从库当前复制的状态

#
# mysql联合索引

https://www.cnblogs.com/softidea/p/5977860.html

命名规则：表名_字段名
### 1、需要加索引的字段，要在where条件中
### 2、数据量少的字段不需要加索引
### 3、如果where条件中是OR关系，加索引不起作用
### 4、符合最左原则
    联合索引又叫复合索引。对于复合索引:Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。例如索引是key index (a,b,c). 可以支持a | a,b| a,b,c 3种组合进行查找，但不支持 b,c进行查找 .当最左侧字段是常量引用时，索引就十分有效。

## MySql在建立索引优化时需要注意的问题


2，复合索引

比如有一条语句是这样的：select * from users where area=’beijing’ and age=22;

如果我们是在area和age上分别创建单个索引的话，由于***mysql查询每次只能使用一个索引***(用多个反而会慢)，所以虽然这样已经相对不做索引时全表扫描提高了很多效率，但是如果在area、age两列上创建复合索引的话将带来更高的效率。如果我们创建了(area, age,salary)的复合索引，那么其实相当于创建了(area,age,salary)、(area,age)、(area)三个索引，这被称为最佳左前缀特性。因此我们在创建复合索引时应该将最常用作限制条件的列放在最左边，依次递减。

3，索引不会包含有NULL值的列

只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL。

4，使用短索引

对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的 列，如果在前10 个或20 个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。

5，排序的索引问题

mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。

6，like语句操作

一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” 不会使用索引而like “aaa%”可以使用索引。

7，不要在列上进行运算

select * from users where YEAR(adddate)

8，不使用NOT IN

NOT IN都不会使用索引将进行全表扫描。NOT IN可以NOT EXISTS代替
