mysql索引、B+树   叶子节点存信息，叶子节点双向链表

B树比平衡树减少IO次数，B+树比B树多范围查找，减少IO次数

	回表：先定位主键值，再定位记录，扫描两遍索引
	聚集索引，叶子节点存储行记录；
	普通索引，叶子节点存储PK值。

索引覆盖
	只需要在一棵索引树上就能获取SQL所需的所有列数据，无需回表，速度更快。
如何实现索引覆盖
	常见的方法是：将被查询的字段，建立到联合索引里去。
MySQL聚集索引和非聚集索引
聚集索引
索引中键值的逻辑顺序决定了表中相应行的物理顺序。
聚集索引确定表中数据的物理顺序。聚集索引类似于电话簿，后者按姓氏排列数据。 聚集索引对于那些经常要搜索范围值的列特别有效。使用聚集索引找到包含第一个值的行后，便可以确保包含后续索引值的行在物理相邻。

非聚集索引
索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同。
非聚集索引的存储结构与前面是一样的，不同的是在叶子结点的数据部分存的不再是具体的数据，而数据的聚集索引的key。所以通过非聚集索引查找的过程是先找到该索引key对应的聚集索引的key，然后再拿聚集索引的key到主键索引树上查找对应的数据，这个过程称为回表！

一、索引种类
	普通索引：仅加速查询
	唯一索引：加速查询 + 列值唯一（可以有null）
	主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个
	组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并
	全文索引：对文本的内容进行分词，进行搜索


二、建立索引的原则：
	定义主键的数据列一定要建立索引。
	定义有外键的数据列一定要建立索引。
	对于经常查询的数据列最好建立索引。
	对于需要在指定范围内的快速或频繁查询的数据列;
	经常用在WHERE子句中的数据列。
	经常出现在关键字order by、group by、distinct后面的字段，建立索引。如果建立的是复合索引，索引的字段顺序要和这些关键字后面的字段顺序一致，否则索引不会被使用。
	对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。
	对于定义为text、image和bit的数据类型的列不要建立索引。
	对于经常存取的列避免建立索引
	限制表上的索引数目。对一个存在大量更新操作的表，所建索引的数目一般不要超过3个，最多不要超过5个。索引虽说提高了访问速度，但太多索引会影响数据的更新操作。
	对复合索引，按照字段在查询条件中出现的频度建立索引。在复合索引中，记录首先按照第一个字段排序。对于在第一个字段上取值相同的记录，系统再按照第二个字段的取值排序，以此类推。因此只有复合索引的第一个字段出现在查询条件中，该索引才可能被使用,因此将应用频度高的字段，放置在复合索引的前面，会使系统最大可能地使用此索引，发挥索引的作用。

	MySQL InnoDB 默认行级锁。行级锁都是基于索引的，如果一条 SQL 语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住，这点需要注意。
	
	联合索引：
	建立联合索引create index 索引名 on 表名(column_1, column_2, column_3);
	(column_2,column_3)这样的查询命中不到索引
	
	最左匹配原则：和b+树存储结构相关，查询次数多的放左边
	
	EXPLAIN查看执行计划 分析查询效率
	
						
	
	索引无效情况：
	1、如果条件中有 or ，即使其中有条件带索引也不会使用  除非将or条件中的每个列都加上索引
	2、like查询是以%开头，索引不会命中
	3、如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引
	4. 没有查询条件，或者查询条件没有建立索引
	5. 查询条件中，在索引列上使用函数（+, - ,*,/）, 这种情况下需建立函数索引
	6. 采用 not in, not exist
	7. B-tree 索引 is null 不会走， is not null 会走
	8、where字句中使用方法
	
事务
	构成事务的所有操作,要么全都对数据库产生影响,要么全都不产生影响,即不
	管事务是否执行成功,数据库总能保持一致性状态。
	事务有ACID特性
	原子性(Atomicity)
	一致性(Consistency):事务的执行结果必须使数据库从一个一致性状态到另一个一致性状态。
	隔离性(Isolation):并发执行的事务不会相互影响
	持久性(Durability):
	
事务的实现
	前面讲的重做日志，回滚日志以及锁技术就是实现事务的基础。
	事务的原子性是通过 undo log 来实现的
	事务的持久性性是通过 redo log 来实现的
	事务的隔离性是通过 (读写锁+MVCC)来实现的
	而事务的终极大 boss 一致性是通过原子性，持久性，隔离性来实现的！！！
	原子性，持久性，隔离性折腾半天的目的也是为了保障数据的一致性！
	
事务的隔离级别：

	  读未提交(READ UNCOMMITTED)
	  读已提交(READ COMMITTED)
	  可重复读(REPEATABLE READ)
	  串行化(SERIALIZABLE)

脏读
	脏读是指当一个事务正在访问数据，并且对数据进行了修改。而这种修改还没有提交到数据库中，这时，另外一个事务也访问了这个数据，然后使用了这个数据。
幻读
	幻读是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到了表中的全部数据行。同时，第二个事务也修改了这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好像发生了幻觉一样。
不可重复读
	不可重复读是指一个事务内多次根据同一查询条件查询出来的同一行记录的值不一致。

         隔离级别	    	脏读	不可重复读	幻读
READ UNCOMMITED (读未提交)	允许	允许	允许
READ COMMITED (读已提交)	 不允许  	 允许	 允许
REPEATABLE READ (可重复读)（默认隔离级别）	不允许	不允许	允许
SERIALIZABLE (串行化)	不允许	不允许	不允许

							

mysql在可重复读隔离级别下怎么解决幻读
	MySQL的Gap锁
	MySQL的共享锁(读锁)和排它锁（写锁）大家应该都比较熟悉了，那gap锁是什么东西呢？
	
	1. select *from user where age>0 and age<10 for update;
	2. 或者
	3. select *from user where age>0 and age<10;
	4. 或者
	5. select *from user where age>0 and age<10 in share mode;
	举个栗子，我们在一个事务中执行上述的SQL语句,数据库中只有age=1，age=4，age=7，age=8 这三条满足条件的记录,那么gap锁会加到age=2，3，5，6，9上面，如果另外一个事务里面想insert age=2，3，5，6，9 是会被阻塞的，因为第一个事务拿到了gap锁。
	
临键锁(next-key)。根据索引，划分为一个个左开右闭的区间。当进行范围查询的时候，若命中索引且能够检索到数据，则锁住记录所在的区间和它的下一个区间
	 
	MySql中如果是快照读，那么是通过MVCC(多版本控制)来避免幻读.
	如果是当前读，那么是通过gap锁来避免幻读
	• 排它锁解决脏读
	• 共享锁解决不可重复读
	• 临键锁解决幻读

1.1 什么是MVCC
		MVCC是一种多版本并发控制机制。
	1.2 MVCC是为了解决什么问题?
		大多数的MYSQL事务型存储引擎,如,InnoDB不使用一种简单的行锁机制。他们都和MVCC–多版本并发控制来一起使用。
		大家都应该知道,锁机制可以控制并发操作,但是其系统开销较大,而MVCC可以在大多数情况下代替行级锁,使用MVCC,能降低其系统开销.
	1.3 MVCC实现
		MVCC是通过保存数据在某个时间点的快照来实现的. 不同存储引擎的MVCC. 不同存储引擎的MVCC实现是不同的,典型的有乐观并发控制和悲观并发控制。
	2.MVCC 具体实现分析
		InnoDB的MVCC,是通过在每行记录后面保存两个隐藏的列来实现的,这两个列，分别保存了系统版本号(可以理解为事务的ID)，每开始一个新的事务，系统版本号就会自动递增，事务开始时刻的系统版本号会作为事务的ID。
		
		不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作。
	
一、MySQL常用存储引擎及特点
1、InnoDB存储引擎
	从MySQL5.5版本之后，MySQL的默认内置存储引擎已经是InnoDB了，他的主要特点有：
	（1）灾难恢复性比较好；
	（2）支持事务。默认的事务隔离级别为可重复读。
	（3）使用的锁粒度为行级锁，可以支持更高的并发；
	（4）支持外键；
	（5）在InnoDB中存在着缓冲管理，通过缓冲池，将索引和数据全部缓存起来，加快查询的速度；
	（6）配合一些热备工具可以支持在线热备份；
	（7）对于InnoDB类型的表，其数据的物理组织形式是聚簇表。所有的数据按照主键来组织。数据和索引放在一块，都位于B+树的叶子节点上；
2、MyISAM存储引擎
	在5.5版本之前，MyISAM是MySQL的默认存储引擎，该存储引擎并发性差，不支持事务，所以使用场景比较少，主要特点为：
	（1）不支持事务；
	（2）不支持外键，如果强行增加外键，不会提示错误，只是外键不其作用；
	（3）对数据的查询缓存只会缓存索引，不会像InnoDB一样缓存数据，而且是利用操作系统本身的缓存；
	（4）默认的锁粒度为表级锁，所以并发度很差，加锁快，锁冲突较少，所以不太容易发生死锁；
	（5）支持全文索引（MySQL5.6之后，InnoDB存储引擎也对全文索引做了支持），但是MySQL的全文索引基本不会使用，对于全文索引，现在有其他成熟的解决方案，比如：ElasticSearch，Solr，Sphinx等。
	（6）数据库所在主机如果宕机，MyISAM的数据文件容易损坏，而且难恢复；
3、MEMORY存储引擎
	将数据存在内存中，和市场上的Redis，memcached等思想类似，为了提高数据的访问速度，主要特点：
	（1）支持的数据类型有限制，比如：不支持TEXT和BLOB类型，对于字符串类型的数据，只支持固定长度的行，VARCHAR会被自动存储为CHAR类型；
	（2）支持的锁粒度为表级锁。所以，在访问量比较大时，表级锁会成为MEMORY存储引擎的瓶颈；
	（3）由于数据是存放在内存中，所以在服务器重启之后，所有数据都会丢失；
	（4）查询的时候，如果有用到临时表，而且临时表中有BLOB，TEXT类型的字段，那么这个临时表就会转化为MyISAM类型的表，性能会急剧降低；
4、ARCHIVE存储引擎
	ARCHIVE存储引擎适合的场景有限，由于其支持压缩，故主要是用来做日志，流水等数据的归档，主要特点：
	（1）支持Zlib压缩，数据在插入表之前，会先被压缩；
	（2）仅支持SELECT和INSERT操作，存入的数据就只能查询，不能做修改和删除；
	（3）只支持自增键上的索引，不支持其他索引；

5、CSV存储引擎
	数据中转试用，主要特点：
	（1）其数据格式为.csv格式的文本，可以直接编辑保存；
	（2）导入导出比较方便，可以将某个表中的数据直接导出为csv，试用Excel办公软件打开；

二、InnoDB和MyISAM的对比
	1、由于锁粒度的不同，InnoDB比MyISAM支持更高的并发；
	2、InnoDB为行级锁，MyISAM为表级锁，所以InnoDB相对于MyISAM来说，更容易发生死锁，锁冲突的概率更大，而且上锁的开销也更大，因为需要为每一行加锁；
	3、在备份容灾上，InnoDB支持在线热备，有很成熟的在线热备解决方案；
	4、查询性能上，MyISAM的查询效率高于InnoDB，因为InnoDB在查询过程中，是需要维护数据缓存，而且查询过程是先定位到行所在的数据块，然后在从数据块中定位到要查找的行；而MyISAM可以直接定位到数据所在的内存地址，可以直接找到数据；
	5、SELECT COUNT(*)语句，如果行数在千万级别以上，MyISAM可以快速查出，而InnoDB查询的特别慢，因为MyISAM将行数单独存储了，而InnoDB需要朱行去统计行数；所以如果使用InnoDB，而且需要查询行数，则需要对行数进行特殊处理，如：离线查询并缓存；
	6、MyISAM的表结构文件包括：.frm(表结构定义),.MYI(索引),.MYD(数据)；而InnoDB的表数据文件为:.ibd和.frm(表结构定义)；


	InnoDB: 其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”。而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，在走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。
	只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！
	在不通过索引条件查询的时候，InnoDB确实使用的是表锁，而不是行锁。

	MyISAM: B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。

MyISAM和InnoDB存储引擎使用的锁：

	MyISAM采用表级锁(table-level locking)。InnoDB支持行级锁(row-level locking)和表级锁,默认为行级锁

表级锁和行级锁对比：

	表级锁： Mysql中锁定粒度最大的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。

	行级锁： Mysql中锁定粒度最小的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。
	
	


三、如何选择合适的存储引擎
	1、使用场景是否需要事务支持；
	2、是否需要支持高并发，InnoDB的并发度远高于MyISAM；
	3、是否需要支持外键；
	4、是否需要支持在线热备；
	5、高效缓冲数据，InnoDB对数据和索引都做了缓冲，而MyISAM只缓冲了索引；
	6、索引，不同存储引擎的索引并不太一样；


七、大表优化
当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：
	限定数据的范围： 务必禁止不带任何限制数据范围条件的查询语句。
	读/写分离： 经典的数据库拆分方案，主库负责写，从库负责读；
	缓存： 使用MySQL的缓存，另外对重量级、更新少的数据可以考虑使用应用级别的缓存；
	垂直分区：
		根据数据库里面数据表的相关性进行拆分。 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。
	直拆分的优点：
		可以使得行数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。
	垂直拆分的缺点： 
		主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；
           水平分区：
		保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。
		水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。
		水品拆分可以支持非常大的数据量。
		需要注意的一点是:分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL 并发能力没有什么意义，所以 水品拆分最好分库 。
		水平拆分能够 支持非常大的数据量存储，应用端改造也少，但 分片事务难以解决 ，跨界点Join 性能较差，逻辑复杂。
		
“慢查询”
分析MySQL语句查询性能的方法除了使用 EXPLAIN 输出执行计划，还可以让MySQL记录下查询超过指定时间的语句，我们将超过指定时间的
	SQL语句查询称为“慢查询”。


数据库连接池：目前常用的连接池有：C3P0、DBCP、Proxool

	c3p0与dbcp区别
		a. dbcp默认不自动回收空闲连接，需要手动开启
		b. c3p0默认自动回收空闲连接功能

 JdbcPool.java:
大致思路：1、读取配置文件，将属性值取出

                   2、注册jdbc驱动

                   3、通过数据库连接数和驱动管理器获得相应连接（.getConnection()）,因为DataSource是接口，所以这个方法需要我们手动实现

                   4、重点：实现getConnection()方法

如何保证缓存和数据库的一致性
	延时双删策略

4.什么是存储过程？用什么来调用？
	存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。
	调用：
	1）可以用一个命令对象来调用存储过程。
	2）可以供外部程序调用，比如：java程序。
5.存储过程的优缺点？
	优点：
	1）存储过程是预编译过的，执行效率高。
	2）存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。
	3）安全性高，执行存储过程需要有一定权限的用户。
	4）存储过程可以重复使用，可减少数据库开发人员的工作量。
	缺点：移植性差

11、读写分离：
主数据库负责处理写操作（当然也可以执行读操作），从数据库负责处理读操作，不能执行写操作。


