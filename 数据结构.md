![image](https://img-blog.csdn.net/20180807094112221?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTYyNjAw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

- 快排选最左边为基准的话，先从最右边开始找

# 跳表
## 时空复杂度
时间复杂度为O(log(n)),空间复杂度为 o(n)

## 什么是跳表
跳表全称为跳跃列表，它允许快速查询，插入和删除一个有序连续元素的数据链表。跳跃列表的平均查找和插入时间复杂度都是O(logn)。
快速查询是通过维护一个多层次的链表，且每一层链表中的元素是前一层链表元素的子集（见右边的示意图）。
一开始时，算法在最稀疏的层次进行搜索，直至需要查找的元素在该层两个相邻的元素中间。这时，算法将跳转到下一个层次，重复刚才的搜索，直到找到需要查找的元素为止。

![image](https://pic2.zhimg.com/80/v2-406ac352da4f3c45da01ba5e2c168d9d_1440w.jpg)

一张跳跃列表的示意图。每个带有箭头的框表示一个指针, 而每行是一个稀疏子序列的链表；底部的编号框（黄色）表示有序的数据序列。查找从顶部最稀疏的子序列向下进行, 直至需要查找的元素在该层两个相邻的元素中间。

![image](https://pic4.zhimg.com/80/v2-e5efbba6181b40a8468cebc7f99e69d3_1440w.jpg)


# 红黑树
## 红黑树的特性:
- （1）每个节点或者是黑色，或者是红色。
-  (2）根节点是黑色。
- （3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]
- （4）如果一个节点是红色的，则它的子节点必须是黑色的。
- （5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。

注意：
(01) 特性(3)中的叶子节点，是只为空(NIL或null)的节点。
(02) 特性(5)，确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对是接近平衡的二叉树。

红黑树示意图如下：
![image](https://images0.cnblogs.com/i/497634/201403/251730074203156.jpg)

# 红黑树的基本操作(一) 左旋和右旋

### 左旋
对x进行左旋，意味着，将“x的右孩子”设为“x的父亲节点”；即，将 x变成了一个左节点(x成了为z的左孩子)！。 因此，左旋中的“左”，意味着“被旋转的节点将变成一个左节点”。
![image](https://images0.cnblogs.com/i/497634/201403/251734577643655.jpg)

### 右旋
对x进行右旋，意味着，将“x的左孩子”设为“x的父亲节点”；即，将 x变成了一个右节点(x成了为y的右孩子)！ 因此，右旋中的“右”，意味着“被旋转的节点将变成一个右节点”。
![image](https://images0.cnblogs.com/i/497634/201403/251737465769614.jpg)

## 红黑树的基本操作(二) 添加

第一步: 将红黑树当作一颗二叉查找树，将节点插入。  
第二步：将插入的节点着色为"红色"。(违背最少的特性)  
第三步: 通过一系列的旋转或着色等操作，使之重新成为一颗红黑树。  

## 红黑树的基本操作(三) 删除  
第一步：将红黑树当作一颗二叉查找树，将节点删除。  
第二步：通过"旋转和重新着色"等一系列来修正该树，使之重新成为一棵红黑树。  

#
# B-树、B+树

为什么说B+tree比B树更适合实际应用中操作系统的文件索引和数据库索引？

## B+tree的磁盘读写代价更低
B+tree的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。

举个例子，假设磁盘中的一个盘块容纳16bytes，而一个关键字2bytes，一个关键字具体信息指针2bytes。一棵9阶B-tree(一个结点最多8个关键字)的内部结点需要2个盘快。而B+ 树内部结点只需要1个盘快。当需要把内部结点读入内存中的时候，B 树就比B+ 树多一次盘块查找时间(在磁盘中就是盘片旋转的时间)。

## B+tree的查询效率更加稳定
由于非叶子结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

## B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。正是为了解决这个问题，B+树应运而生。B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）。

# LSM(Log Structured Merge Trees)
LSM被设计来提供比传统的B+树或者ISAM更好的写操作吞吐量，通过消去随机的本地更新操作来达到这个目标。