![image](https://img-blog.csdn.net/20180807094112221?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTYyNjAw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

- 快排选最左边为基准的话，先从最右边开始找

# 跳表
## 时空复杂度
时间复杂度为O(log(n)),空间复杂度为 o(n)

## 什么是跳表
跳表全称为跳跃列表，它允许快速查询，插入和删除一个有序连续元素的数据链表。跳跃列表的平均查找和插入时间复杂度都是O(logn)。
快速查询是通过维护一个多层次的链表，且每一层链表中的元素是前一层链表元素的子集（见右边的示意图）。
一开始时，算法在最稀疏的层次进行搜索，直至需要查找的元素在该层两个相邻的元素中间。这时，算法将跳转到下一个层次，重复刚才的搜索，直到找到需要查找的元素为止。

![image](https://pic2.zhimg.com/80/v2-406ac352da4f3c45da01ba5e2c168d9d_1440w.jpg)

一张跳跃列表的示意图。每个带有箭头的框表示一个指针, 而每行是一个稀疏子序列的链表；底部的编号框（黄色）表示有序的数据序列。查找从顶部最稀疏的子序列向下进行, 直至需要查找的元素在该层两个相邻的元素中间。

![image](https://pic4.zhimg.com/80/v2-e5efbba6181b40a8468cebc7f99e69d3_1440w.jpg)


# 红黑树
## 红黑树的特性:
- （1）每个节点或者是黑色，或者是红色。
-  (2）根节点是黑色。
- （3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]
- （4）如果一个节点是红色的，则它的子节点必须是黑色的。
- （5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。

注意：
(01) 特性(3)中的叶子节点，是只为空(NIL或null)的节点。
(02) 特性(5)，确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对是接近平衡的二叉树。

红黑树示意图如下：
![image](https://images0.cnblogs.com/i/497634/201403/251730074203156.jpg)

# 红黑树的基本操作(一) 左旋和右旋

### 左旋
对x进行左旋，意味着，将“x的右孩子”设为“x的父亲节点”；即，将 x变成了一个左节点(x成了为z的左孩子)！。 因此，左旋中的“左”，意味着“被旋转的节点将变成一个左节点”。
![image](https://images0.cnblogs.com/i/497634/201403/251734577643655.jpg)

### 右旋
对x进行右旋，意味着，将“x的左孩子”设为“x的父亲节点”；即，将 x变成了一个右节点(x成了为y的右孩子)！ 因此，右旋中的“右”，意味着“被旋转的节点将变成一个右节点”。
![image](https://images0.cnblogs.com/i/497634/201403/251737465769614.jpg)

## 红黑树的基本操作(二) 添加

第一步: 将红黑树当作一颗二叉查找树，将节点插入。  
第二步：将插入的节点着色为"红色"。(违背最少的特性)  
第三步: 通过一系列的旋转或着色等操作，使之重新成为一颗红黑树。  

## 红黑树的基本操作(三) 删除  
第一步：将红黑树当作一颗二叉查找树，将节点删除。  
第二步：通过"旋转和重新着色"等一系列来修正该树，使之重新成为一棵红黑树。  

#
# B-树、B+树
