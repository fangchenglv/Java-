# 操作系统的页式内存管理
内存管理的目标就是：
地址保护：一个程序不能访问另一个程序地址空间。
地址独立：程序发出的地址应与物理主存地址无关。

1. 虚拟内存  
虚拟内存是操作系统发展史上一个重要的里程碑，虚拟内存的使用，避免程序直接和主存（物理内存）打交道，并且对缓存、主存和磁盘做了统一抽象，这样程序就可以突破物理内存的大小限制，当然程序还是要受制于虚拟内存的大小限制的。
程序中看到的内存地址是虚拟内存地址，程序读写内存时会被映射到实际的物理内存中，这个映射称为翻译，这个翻译工作是由MMU（内存管理单元）来完成，MMU接收CPU发出的虚拟地址，将其翻译为物理地址后发送给内存，内存按照该物理地址进行相应访问后读出或写入相关数据。
2. 分页内存  
分页系统的核心是将虚拟内存空间和物理内存空间皆划分为大小相同的页面，如4KB、8KB或16KB等，并以页面作为内存空间的最小分配单位，一个程序的一个页面可以存放在任意一个物理页面里。
3. 分页管理   
在分页系统下，一个程序发出的虚拟地址由两部分组成：页面号和页内偏移值。为了解决程序比内存大的问题，我们可以允许一个进程的部分虚拟页面存放在磁盘上。在需要访问这些外部虚拟页面时，再将其调入物理内存，需要腾出空间时，将暂时不用的内存swap到磁盘。

分页管理对于任一虚拟页面，系统知道该页面是否在物理内存中，如果在的话，其对应的物理页面是哪个；如果不在的话，则产生一个系统中断（缺页中断），并将该虚页从磁盘转到内存，然后将分配给它的物理页面号返回，这个过程也就是前面说到的地址翻译：

4. 页表
由于页表的特殊地位（使用非常频繁），因此只能由硬件来实现，也即是说它是一个硬件数据结构。  
表页表根据存放的内容可分为：顶级页表、一级页表、二级页表、三级页表等。顶级页表里面存放的是一级页表的信息，一级页表里面存放的是二级页表的信息，以此类推，到最后一级页表存放的才是虚拟页面到物理页面的映射，就和MySQL中非聚集索引和聚集索引的关系类似。





# 进程间通信有哪几种方式？
    1、无名管道
　　无名管道（pipe）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。本机任意两个进程间
　　2、高级管道
　　高级管道（popen）：将另一个程序当做一个新的进程在当前程序进程中启动，则它算是当前程序的子进程，这种方式我们成为高级管道方式。
　　3、有名管道
　　有名管道 （named pipe）：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
　　4、消息队列
　　消息队列（message queue）：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
　　5、信号量
　　信号量（semophore） ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
　　6、信号
　　信号 （ sinal ） ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。
　　7、共享内存
　　共享内存（ shared memory ） ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率
低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。
　　8、套接字
　　套接字（ socket ） ： 套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。

线程间通信有哪几种方式？
	1、消息队列，是最常用的一种，也是最灵活的一种，通过自定义数据结构，可以传输复杂和简单的数据结构。
	2、使用全局变量。
	3、共享内存。
	4、volatile。
	4、JAVA多线程之wait/notify


 进程和线程关系及区别
1.定义
	进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.
	线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.
2.关系
	一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.
	相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。
3.区别
	进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。

	1) 简而言之,一个程序至少有一个进程,一个进程至少有一个线程。
	2) 线程的划分尺度小于进程，使得多线程程序的并发性高。
	3) 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。
	4) 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
	5) 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。
4.优缺点
	线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。
	
僵尸进程
	当一个子进程结束运行（一般是调用exit、运行时发生致命错误或收到终止信号所导致）时，子进程的退出状态（返回值）会回报给操作系统，系统则以SIGCHLD信号将子进程被结束的事件告知父进程，此时子进程的进程控制块（PCB）仍驻留在内存中。一般来说，收到SIGCHLD后，父进程会使用wait系统调用以获取子进程的退出状态，然后内核就可以从内存中释放已结束的子进程的PCB；而如若父进程没有这么做的话，子进程的PCB就会一直驻留在内存中，也即成为僵尸进程
	简单来说，当进程退出但是父进程并没有调用wait或waitpid获取子进程的状态信息时就会产生僵尸进程
	僵尸进程也就会造成资源浪费，所以我们应该避免僵尸进程的产生
孤儿进程
	孤儿进程则是指当一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。
	孤儿进程由于有init进程循环的wait()回收资源，因此并没有什么危害
	
用户态和内核态的理解和区别
	当一个进程在执行用户自己的代码时处于用户运行态（用户态），此时特权级最低，为3级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态。Ring3状态不能访问Ring0的地址空间，包括代码和数据；当一个进程因为系统调用陷入内核代码中执行时处于内核运行态（内核态），此时特权级最高，为0级。执行的内核代码会使用当前进程的内核栈，每个进程都有自己的内核栈。

	用户运行一个程序，该程序创建的进程开始时运行自己的代码，处于用户态。如果要执行文件操作、网络数据发送等操作必须通过write、send等系统调用，这些系统调用会调用内核的代码。

4、用户态和内核态的切换
	（1）系统调用
	（2）异常
	（3）外围设备的中断

什么是虚拟内存？

	虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。目前，大多数操作系统都使用了虚拟内存，如Windows家族的“虚拟内存”；Linux的“交换空间”等。
	虚拟内存的作用

	内存在计算机中的作用很大，电脑中所有运行的程序都需要经过内存来执行，如果执行的程序很大或很多，就会导致内存消耗殆尽。为了解决这个问题，WINDOWS运用了虚拟内存技术，即拿出一部分硬盘空间来充当内存使用，这部分空间即称为虚拟内存，虚拟内存在硬盘上的存在形式就是 PAGEFILE.SYS这个页面文件。

协程
	协程运行在线程之上，当一个协程执行完成后，可以选择主动让出，让另一个协程运行在当前线程之上。协程并没有增加线程数量，只是在线程的基础之上通过分时复用的方式运行多个协程，而且协程的切换在用户态完成，切换的代价比线程从用户态到内核态的代价小很多。
	在有大量IO操作业务的情况下，我们采用协程替换线程，可以到达很好的效果，一是降低了系统内存，二是减少了系统切换开销，因此系统的性能也会提升。
	在协程中尽量不要调用阻塞IO的方法，比如打印，读取文件，Socket接口等，除非改为异步调用的方式，并且协程只有在IO密集型的任务中才会发挥作用。
	协程只有和异步IO结合起来才能发挥出最大的威力。
	
2、select、poll 和 epoll 之间的区别：
（1）select：时间复杂度 O(n)

	select 仅仅知道有 I/O 事件发生，但并不知道是哪几个流，所以只能无差别轮询所有流，找出能读出数据或者写入数据的流，并对其进行操作。所以 select 具有 O(n) 的无差别轮询复杂度，同时处理的流越多，无差别轮询时间就越长。

（2）poll：时间复杂度 O(n)

	poll 本质上和 select 没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个 fd 对应的设备状态， 但是它没有最大连接数的限制，原因是它是基于链表来存储的。

（3）epoll：时间复杂度 O(1)

	epoll 可以理解为 event poll，不同于忙轮询和无差别轮询，epoll 会把哪个流发生了怎样的 I/O 事件通知我们。 所以说 epoll 实际上是事件驱动（每个事件关联上 fd）的。
	
	
IO的五种方式
	程序直接控制
	中断
	DMA
	外围处理机
	通道
	
#
# <font color=yellow size=5>进程间通信有哪几种方式？</font>
## 1、无名管道
### &emsp;&emsp;无名管道（pipe）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。本机任意两个进程间  
## 2、高级管道  
### &emsp;&emsp;高级管道（popen）：将另一个程序当做一个新的进程在当前程序进程中启动，则它算是当前程序的子进程，这种方式我们成为高级管道方式。
## 3、有名管道
### &emsp;&emsp;有名管道 （named pipe）：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
## 4、消息队列
### &emsp;&emsp;消息队列（message queue）：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。   
## 5、信号量    
### &emsp;&emsp;信号量（semophore） ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
## 6、信号
### &emsp;&emsp;信号 （ sinal ） ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。
## 7、共享内存
### &emsp;&emsp;共享内存（ shared memory ） ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。
## 8、套接字
### &emsp;&emsp;套接字（ socket ） ： 套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。
#
# <font color=yellow size=5>线程间通信有哪几种方式？</font>
## 1、消息队列
### &emsp;&emsp;是最常用的一种，也是最灵活的一种，通过自定义数据结构，可以传输复杂和简单的数据结构。
## 2、使用全局变量。
## 3、共享内存。
## 4、volatile。
## 5、JAVA多线程之wait/notify
#
# <font color=yellow size=5>进程和线程关系及区别</font>
## 1.定义
### &emsp;&emsp;<font color=green size=4>**进程**</font>是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.
### &emsp;&emsp;<font color=green size=4>**线程**</font>是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.
## 2.关系
### &emsp;&emsp;一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。
## 3.区别
### &emsp;&emsp;进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。

### &emsp;&emsp;1) 简而言之,一个程序至少有一个进程,一个进程至少有一个线程。
### &emsp;&emsp;2) 线程的划分尺度小于进程，使得多线程程序的并发性高。
### &emsp;&emsp;3) 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。
### &emsp;&emsp;4) 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
### &emsp;&emsp;5) 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。
## 4.优缺点
### &emsp;&emsp;线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。
***
## 僵尸进程
***
### &emsp;&emsp;当一个子进程结束运行（一般是调用exit、运行时发生致命错误或收到终止信号所导致）时，子进程的退出状态（返回值）会回报给操作系统，系统则以SIGCHLD信号将子进程被结束的事件告知父进程，此时子进程的进程控制块（PCB）仍驻留在内存中。一般来说，收到SIGCHLD后，父进程会使用wait系统调用以获取子进程的退出状态，然后内核就可以从内存中释放已结束的子进程的PCB；而如若父进程没有这么做的话，子进程的PCB就会一直驻留在内存中，也即成为僵尸进程
### &emsp;&emsp;简单来说，当进程退出但是父进程并没有调用wait或waitpid获取子进程的状态信息时就会产生僵尸进程.僵尸进程也就会造成资源浪费，所以我们应该避免僵尸进程的产生.
***
## 孤儿进程
***
### &emsp;&emsp;孤儿进程则是指当一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。
### 孤儿进程由于有init进程循环的wait()回收资源，因此并没有什么危害



#
# <font color=yellow size=5>线程的各种状态</font>

### &emsp;&emsp;线程从创建、运行到结束总是处于下面五个状态之一：新建状态、就绪状态、运行状态、阻塞状态及死亡状态。  

![image](https://images2017.cnblogs.com/blog/1252584/201712/1252584-20171216161451499-1101244651.png)

## 1.新建状态

### &emsp;&emsp;当用new操作符创建一个线程时。此时程序还没有开始运行线程中的代码。

## 2.就绪状态

### &emsp;&emsp;一个新创建的线程并不自动开始运行，要执行线程，必须调用线程的start()方法。当线程对象调用start()方法即启动了线程，start()方法创建线程运行的系统资源，并调度线程运行run()方法。当start()方法返回后，线程就处于就绪状态。

### &emsp;&emsp;处于就绪状态的线程并不一定立即运行run()方法，线程还必须同其他线程竞争CPU时间，只有获得CPU时间才可以运行线程。因为在单CPU的计算机系统中，不可能同时运行多个线程，一个时刻仅有一个线程处于运行状态。因此此时可能有多个线程处于就绪状态。对多个处于就绪状态的线程是由Java运行时系统的线程调度程序来调度的。

## 3.运行状态（running）

### &emsp;&emsp;当线程获得CPU时间后，它才进入运行状态，真正开始执行run()方法。

## 4.阻塞状态（blocked）

### &emsp;&emsp;所谓阻塞状态是正在运行的线程没有运行结束，暂时让出CPU，这时其他处于就绪状态的线程就可以获得CPU时间，进入运行状态。线程运行过程中，可能由于各种原因进入阻塞状态：

### &emsp;&emsp;(1)线程通过调用sleep方法进入睡眠状态；

### &emsp;&emsp;(2)线程调用一个在I/O上被阻塞的操作，即该操作在输入输出操作完成之前不会返回到它的调用者；

### &emsp;&emsp;(3)线程试图得到一个锁，而该锁正被其他线程持有；

### &emsp;&emsp;(4)线程在等待某个触发条件；


---

## 线程被堵塞可能是由下述五方面的原因造成的：
---

### &emsp;&emsp;(1) 调用sleep(毫秒数)，使线程进入"睡眠"状态。在规定的时间内，这个线程是不会运行的。

### &emsp;&emsp;(2) 用suspend()暂停了线程的执行。除非线程收到resume()消息，否则不会返回"可运行"状态。

### &emsp;&emsp;(3) 用wait()暂停了线程的执行。除非线程收到nofify()或者notifyAll()消息，否则不会变成"可运行"（是的，这看起来同原因2非常相象，但有一个明显的区别是我们马上要揭示的）。

### &emsp;&emsp;(4) 线程正在等候一些IO（输入输出）操作完成。

### &emsp;&emsp;(5) 线程试图调用另一个对象的"同步"方法，但那个对象处于锁定状态，暂时无法使用。
---
## 5.死亡状态（dead）

### &emsp;&emsp;有两个原因会导致线程死亡：①run方法正常退出而自然死亡；②一个未捕获的异常终止了run方法而使线程猝死；

---
# <font color=yellow size=5>判断线程是阻塞还是死亡</font>

### &emsp;&emsp;所谓阻塞状态是正在运行的线程没有运行结束，暂时让出CPU，这时其他处于就绪状态的线程就可以获得CPU时间，进入运行状态。为了确定线程在当前是否存活着（就是要么是可运行的，要么是被阻塞了），需要使用<font color=yellow>**isAlive**</font>方法，如果是可运行或被阻塞，这个方法返回true；如果线程仍旧是new状态且不是可运行的，或者线程死亡了，则返回false。

#
# <font color=yellow size=5>用户态和内核态的理解和区别</font>
### &emsp;&emsp;当一个进程在执行用户自己的代码时处于用户运行态（用户态），此时特权级最低，为3级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态。Ring3状态不能访问Ring0的地址空间，包括代码和数据；当一个进程因为系统调用陷入内核代码中执行时处于内核运行态（内核态），此时特权级最高，为0级。执行的内核代码会使用当前进程的内核栈，每个进程都有自己的内核栈。

### &emsp;&emsp;用户运行一个程序，该程序创建的进程开始时运行自己的代码，处于用户态。如果要执行文件操作、网络数据发送等操作必须通过write、send等系统调用，这些系统调用会调用内核的代码。
***
## 用户态和内核态的切换
***
- ### 系统调用
- ### 异常
- ### 外围设备的中断
#
# <font color=yellow size=5>什么是虚拟内存？</font>
### &emsp;&emsp;虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。目前，大多数操作系统都使用了虚拟内存，如Windows家族的“虚拟内存”；Linux的“交换空间”等。
#
# <font color=yellow size=5>虚拟内存的作用</font>

### &emsp;&emsp;内存在计算机中的作用很大，电脑中所有运行的程序都需要经过内存来执行，如果执行的程序很大或很多，就会导致内存消耗殆尽。为了解决这个问题，WINDOWS运用了虚拟内存技术，即拿出一部分硬盘空间来充当内存使用，这部分空间即称为虚拟内存，虚拟内存在硬盘上的存在形式就是 PAGEFILE.SYS这个页面文件。
#
# <font color=yellow size=5>协程</font>
### &emsp;&emsp;协程运行在线程之上，当一个协程执行完成后，可以选择主动让出，让另一个协程运行在当前线程之上。协程并没有增加线程数量，只是在线程的基础之上通过分时复用的方式运行多个协程，而且协程的切换在用户态完成，切换的代价比线程从用户态到内核态的代价小很多。
### &emsp;&emsp;在有大量IO操作业务的情况下，我们采用协程替换线程，可以到达很好的效果，一是降低了系统内存，二是减少了系统切换开销，因此系统的性能也会提升。
### 在协程中尽量不要调用阻塞IO的方法，比如打印，读取文件，Socket接口等，除非改为异步调用的方式，并且协程只有在IO密集型的任务中才会发挥作用。
### &emsp;&emsp;协程只有和异步IO结合起来才能发挥出最大的威力。
#
# 阻塞非阻塞与同步异步的区别

### &emsp;&emsp;1. 同步和异步关注的是<font color=yellow>消息通信机制</font>，所谓同步，就是在发出一个调用时，在没有得到结果之前，该调用就不返回。但是一旦调用返回，就得到返回值了。而异步则是相反，调用在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用。你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下"，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。
### &emsp;&emsp;2. 阻塞和非阻塞关注的是程序在<font color=yellow>等待调用结果（消息，返回值）时的状态</font>。阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。
#
# BIO NIO AIO区别
### 1. BIO：同步并阻塞，服务器实现模式为<font color=yellow>**一个连接一个线程**</font>，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。
### 2. NIO：同步非阻塞，服务器实现模式为<font color=yellow>**一个请求一个线程**</font>，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。Channel、Selector、Buffer
### 3. AIO：异步非阻塞，服务器实现模式为<font color=yellow>**一个有效请求一个线程**</font>，客户端的 IO 请求都是由 OS 先完成了再通知服务器应用去启动线程进行处理
#
# 选择器

### NIO 常常被叫做非阻塞 IO，主要是因为 NIO 在网络通信中的非阻塞特性被广泛使用。
### NIO 实现了 IO 多路复用中的 Reactor 模型，一个线程 Thread 使用一个选择器 Selector 通过轮询的方式去监听多个通道 Channel 上的事件，从而让一个线程就可以处理多个事件。
### 通过配置监听的通道 Channel 为非阻塞，那么当 Channel 上的 IO 事件还未到达时，就不会进入阻塞状态一直等待，而是继续轮询其它 Channel，找到 IO 事件已经到达的 Channel 执行。
### 因为创建和切换线程的开销很大，因此使用一个线程来处理多个事件而不是一个线程处理一个事件，对于 IO 密集型的应用具有很好地性能。
### 应该注意的是，只有套接字 Channel 才能配置为非阻塞，而 FileChannel 不能，为 FileChannel 配置非阻塞也没有意义。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/093f9e57-429c-413a-83ee-c689ba596cef.png" width="350px"> </div><br>

#
# Reactor模式
实际上的Reactor模式，是基于Java NIO的，在他的基础上，抽象出来两个组件——Reactor和Handler两个组件：

（1）Reactor：负责响应IO事件，当检测到一个新的事件，将其发送给相应的Handler去处理；新的事件包含连接建立就绪、读就绪、写就绪等。

（2）Handler:将自身（handler）与事件绑定，负责事件的处理，完成channel的读入，完成处理业务逻辑后，负责将结果写出channel。
![image](https://img2018.cnblogs.com/blog/1485398/201810/1485398-20181022232216603-150952598.jpg)  
单线程Reactor模型
#
# select、poll、epoll之间的区别
### &emsp;&emsp;select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。
## 1. select==>时间复杂度O(n)
### &emsp;&emsp;它仅仅知道了，有I/O事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以select具有O(n)的无差别轮询复杂度，同时处理的流越多，无差别轮询时间就越长。
## 2. poll==>时间复杂度O(n)
### &emsp;&emsp;poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， 但是它没有最大连接数的限制，原因是它是基于链表来存储的.
## 3. epoll==>时间复杂度O(1)
### &emsp;&emsp;epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。所以epoll是事件驱动（每个事件关联上fd）的，此时我们对这些流的操作都是有意义的。（复杂度降低到了O(1)）
	
#
# <font color=yellow size=5>IO的五种方式</font>
- ### 程序直接控制
- ### 中断
- ### DMA
- ### 外围处理机
- ### 通道
	



