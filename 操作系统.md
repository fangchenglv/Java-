进程间通信有哪几种方式？
    1、无名管道
　　无名管道（pipe）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。本机任意两个进程间
　　2、高级管道
　　高级管道（popen）：将另一个程序当做一个新的进程在当前程序进程中启动，则它算是当前程序的子进程，这种方式我们成为高级管道方式。
　　3、有名管道
　　有名管道 （named pipe）：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
　　4、消息队列
　　消息队列（message queue）：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
　　5、信号量
　　信号量（semophore） ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
　　6、信号
　　信号 （ sinal ） ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。
　　7、共享内存
　　共享内存（ shared memory ） ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率
低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。
　　8、套接字
　　套接字（ socket ） ： 套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。

线程间通信有哪几种方式？
	1、消息队列，是最常用的一种，也是最灵活的一种，通过自定义数据结构，可以传输复杂和简单的数据结构。
	2、使用全局变量。
	3、共享内存。
	4、volatile。
	4、JAVA多线程之wait/notify


 进程和线程关系及区别
1.定义
	进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.
	线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.
2.关系
	一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.
	相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。
3.区别
	进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。

	1) 简而言之,一个程序至少有一个进程,一个进程至少有一个线程。
	2) 线程的划分尺度小于进程，使得多线程程序的并发性高。
	3) 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。
	4) 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
	5) 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。
4.优缺点
	线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。
	
僵尸进程
	当一个子进程结束运行（一般是调用exit、运行时发生致命错误或收到终止信号所导致）时，子进程的退出状态（返回值）会回报给操作系统，系统则以SIGCHLD信号将子进程被结束的事件告知父进程，此时子进程的进程控制块（PCB）仍驻留在内存中。一般来说，收到SIGCHLD后，父进程会使用wait系统调用以获取子进程的退出状态，然后内核就可以从内存中释放已结束的子进程的PCB；而如若父进程没有这么做的话，子进程的PCB就会一直驻留在内存中，也即成为僵尸进程
	简单来说，当进程退出但是父进程并没有调用wait或waitpid获取子进程的状态信息时就会产生僵尸进程
	僵尸进程也就会造成资源浪费，所以我们应该避免僵尸进程的产生
孤儿进程
	孤儿进程则是指当一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。
	孤儿进程由于有init进程循环的wait()回收资源，因此并没有什么危害
	
用户态和内核态的理解和区别
	当一个进程在执行用户自己的代码时处于用户运行态（用户态），此时特权级最低，为3级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态。Ring3状态不能访问Ring0的地址空间，包括代码和数据；当一个进程因为系统调用陷入内核代码中执行时处于内核运行态（内核态），此时特权级最高，为0级。执行的内核代码会使用当前进程的内核栈，每个进程都有自己的内核栈。

	用户运行一个程序，该程序创建的进程开始时运行自己的代码，处于用户态。如果要执行文件操作、网络数据发送等操作必须通过write、send等系统调用，这些系统调用会调用内核的代码。

4、用户态和内核态的切换
	（1）系统调用
	（2）异常
	（3）外围设备的中断

什么是虚拟内存？

	虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。目前，大多数操作系统都使用了虚拟内存，如Windows家族的“虚拟内存”；Linux的“交换空间”等。
	虚拟内存的作用

	内存在计算机中的作用很大，电脑中所有运行的程序都需要经过内存来执行，如果执行的程序很大或很多，就会导致内存消耗殆尽。为了解决这个问题，WINDOWS运用了虚拟内存技术，即拿出一部分硬盘空间来充当内存使用，这部分空间即称为虚拟内存，虚拟内存在硬盘上的存在形式就是 PAGEFILE.SYS这个页面文件。

协程
	协程运行在线程之上，当一个协程执行完成后，可以选择主动让出，让另一个协程运行在当前线程之上。协程并没有增加线程数量，只是在线程的基础之上通过分时复用的方式运行多个协程，而且协程的切换在用户态完成，切换的代价比线程从用户态到内核态的代价小很多。
	在有大量IO操作业务的情况下，我们采用协程替换线程，可以到达很好的效果，一是降低了系统内存，二是减少了系统切换开销，因此系统的性能也会提升。
	在协程中尽量不要调用阻塞IO的方法，比如打印，读取文件，Socket接口等，除非改为异步调用的方式，并且协程只有在IO密集型的任务中才会发挥作用。
	协程只有和异步IO结合起来才能发挥出最大的威力。
	
2、select、poll 和 epoll 之间的区别：
（1）select：时间复杂度 O(n)

	select 仅仅知道有 I/O 事件发生，但并不知道是哪几个流，所以只能无差别轮询所有流，找出能读出数据或者写入数据的流，并对其进行操作。所以 select 具有 O(n) 的无差别轮询复杂度，同时处理的流越多，无差别轮询时间就越长。

（2）poll：时间复杂度 O(n)

	poll 本质上和 select 没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个 fd 对应的设备状态， 但是它没有最大连接数的限制，原因是它是基于链表来存储的。

（3）epoll：时间复杂度 O(1)

	epoll 可以理解为 event poll，不同于忙轮询和无差别轮询，epoll 会把哪个流发生了怎样的 I/O 事件通知我们。 所以说 epoll 实际上是事件驱动（每个事件关联上 fd）的。
	
	
	IO的五种方式
	程序直接控制
	中断
	DMA
	外围处理机
	通道
	
#
# <font color=yellow size=5>进程间通信有哪几种方式？</font>
## 1、无名管道
### &emsp;&emsp;无名管道（pipe）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。本机任意两个进程间  
## 2、高级管道  
### &emsp;&emsp;高级管道（popen）：将另一个程序当做一个新的进程在当前程序进程中启动，则它算是当前程序的子进程，这种方式我们成为高级管道方式。
## 3、有名管道
### &emsp;&emsp;有名管道 （named pipe）：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
## 4、消息队列
### &emsp;&emsp;消息队列（message queue）：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。   
## 5、信号量    
### &emsp;&emsp;信号量（semophore） ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
## 6、信号
### &emsp;&emsp;信号 （ sinal ） ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。
## 7、共享内存
### &emsp;&emsp;共享内存（ shared memory ） ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。
## 8、套接字
### &emsp;&emsp;套接字（ socket ） ： 套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。
#
# <font color=yellow size=5>线程间通信有哪几种方式？</font>
## 1、消息队列
### &emsp;&emsp;是最常用的一种，也是最灵活的一种，通过自定义数据结构，可以传输复杂和简单的数据结构。
## 2、使用全局变量。
## 3、共享内存。
## 4、volatile。
## 5、JAVA多线程之wait/notify
#
# <font color=yellow size=5>进程和线程关系及区别</font>
## 1.定义
### &emsp;&emsp;<font color=green size=4>**进程**</font>是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.
### &emsp;&emsp;<font color=green size=4>**线程**</font>是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.
## 2.关系
### &emsp;&emsp;一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。
## 3.区别
### &emsp;&emsp;进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。

### &emsp;&emsp;1) 简而言之,一个程序至少有一个进程,一个进程至少有一个线程。
### &emsp;&emsp;2) 线程的划分尺度小于进程，使得多线程程序的并发性高。
### &emsp;&emsp;3) 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。
### &emsp;&emsp;4) 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
### &emsp;&emsp;5) 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。
## 4.优缺点
### &emsp;&emsp;线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。
***
## 僵尸进程
***
### &emsp;&emsp;当一个子进程结束运行（一般是调用exit、运行时发生致命错误或收到终止信号所导致）时，子进程的退出状态（返回值）会回报给操作系统，系统则以SIGCHLD信号将子进程被结束的事件告知父进程，此时子进程的进程控制块（PCB）仍驻留在内存中。一般来说，收到SIGCHLD后，父进程会使用wait系统调用以获取子进程的退出状态，然后内核就可以从内存中释放已结束的子进程的PCB；而如若父进程没有这么做的话，子进程的PCB就会一直驻留在内存中，也即成为僵尸进程
### &emsp;&emsp;简单来说，当进程退出但是父进程并没有调用wait或waitpid获取子进程的状态信息时就会产生僵尸进程.僵尸进程也就会造成资源浪费，所以我们应该避免僵尸进程的产生.
***
## 孤儿进程
***
### &emsp;&emsp;孤儿进程则是指当一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。
### 孤儿进程由于有init进程循环的wait()回收资源，因此并没有什么危害



#
# <font color=yellow size=5>线程的各种状态</font>

### &emsp;&emsp;线程从创建、运行到结束总是处于下面五个状态之一：新建状态、就绪状态、运行状态、阻塞状态及死亡状态。  

![image](https://images2017.cnblogs.com/blog/1252584/201712/1252584-20171216161451499-1101244651.png)

## 1.新建状态

### &emsp;&emsp;当用new操作符创建一个线程时。此时程序还没有开始运行线程中的代码。

## 2.就绪状态

### &emsp;&emsp;一个新创建的线程并不自动开始运行，要执行线程，必须调用线程的start()方法。当线程对象调用start()方法即启动了线程，start()方法创建线程运行的系统资源，并调度线程运行run()方法。当start()方法返回后，线程就处于就绪状态。

### &emsp;&emsp;处于就绪状态的线程并不一定立即运行run()方法，线程还必须同其他线程竞争CPU时间，只有获得CPU时间才可以运行线程。因为在单CPU的计算机系统中，不可能同时运行多个线程，一个时刻仅有一个线程处于运行状态。因此此时可能有多个线程处于就绪状态。对多个处于就绪状态的线程是由Java运行时系统的线程调度程序来调度的。

## 3.运行状态（running）

### &emsp;&emsp;当线程获得CPU时间后，它才进入运行状态，真正开始执行run()方法。

## 4.阻塞状态（blocked）

### &emsp;&emsp;所谓阻塞状态是正在运行的线程没有运行结束，暂时让出CPU，这时其他处于就绪状态的线程就可以获得CPU时间，进入运行状态。线程运行过程中，可能由于各种原因进入阻塞状态：

### &emsp;&emsp;(1)线程通过调用sleep方法进入睡眠状态；

### &emsp;&emsp;(2)线程调用一个在I/O上被阻塞的操作，即该操作在输入输出操作完成之前不会返回到它的调用者；

### &emsp;&emsp;(3)线程试图得到一个锁，而该锁正被其他线程持有；

### &emsp;&emsp;(4)线程在等待某个触发条件；


---

## 线程被堵塞可能是由下述五方面的原因造成的：
---

### &emsp;&emsp;(1) 调用sleep(毫秒数)，使线程进入"睡眠"状态。在规定的时间内，这个线程是不会运行的。

### &emsp;&emsp;(2) 用suspend()暂停了线程的执行。除非线程收到resume()消息，否则不会返回"可运行"状态。

### &emsp;&emsp;(3) 用wait()暂停了线程的执行。除非线程收到nofify()或者notifyAll()消息，否则不会变成"可运行"（是的，这看起来同原因2非常相象，但有一个明显的区别是我们马上要揭示的）。

### &emsp;&emsp;(4) 线程正在等候一些IO（输入输出）操作完成。

### &emsp;&emsp;(5) 线程试图调用另一个对象的"同步"方法，但那个对象处于锁定状态，暂时无法使用。
---
## 5.死亡状态（dead）

### &emsp;&emsp;有两个原因会导致线程死亡：①run方法正常退出而自然死亡；②一个未捕获的异常终止了run方法而使线程猝死；

---
# <font color=yellow size=5>判断线程是阻塞还是死亡</font>

### &emsp;&emsp;所谓阻塞状态是正在运行的线程没有运行结束，暂时让出CPU，这时其他处于就绪状态的线程就可以获得CPU时间，进入运行状态。为了确定线程在当前是否存活着（就是要么是可运行的，要么是被阻塞了），需要使用<font color=yellow>**isAlive**</font>方法，如果是可运行或被阻塞，这个方法返回true；如果线程仍旧是new状态且不是可运行的，或者线程死亡了，则返回false。

#
# <font color=yellow size=5>用户态和内核态的理解和区别</font>
### &emsp;&emsp;当一个进程在执行用户自己的代码时处于用户运行态（用户态），此时特权级最低，为3级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态。Ring3状态不能访问Ring0的地址空间，包括代码和数据；当一个进程因为系统调用陷入内核代码中执行时处于内核运行态（内核态），此时特权级最高，为0级。执行的内核代码会使用当前进程的内核栈，每个进程都有自己的内核栈。

### &emsp;&emsp;用户运行一个程序，该程序创建的进程开始时运行自己的代码，处于用户态。如果要执行文件操作、网络数据发送等操作必须通过write、send等系统调用，这些系统调用会调用内核的代码。
***
## 用户态和内核态的切换
***
- ### 系统调用
- ### 异常
- ### 外围设备的中断
#
# <font color=yellow size=5>什么是虚拟内存？</font>
### &emsp;&emsp;虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。目前，大多数操作系统都使用了虚拟内存，如Windows家族的“虚拟内存”；Linux的“交换空间”等。
#
# <font color=yellow size=5>虚拟内存的作用</font>

### &emsp;&emsp;内存在计算机中的作用很大，电脑中所有运行的程序都需要经过内存来执行，如果执行的程序很大或很多，就会导致内存消耗殆尽。为了解决这个问题，WINDOWS运用了虚拟内存技术，即拿出一部分硬盘空间来充当内存使用，这部分空间即称为虚拟内存，虚拟内存在硬盘上的存在形式就是 PAGEFILE.SYS这个页面文件。
#
# <font color=yellow size=5>协程</font>
### &emsp;&emsp;协程运行在线程之上，当一个协程执行完成后，可以选择主动让出，让另一个协程运行在当前线程之上。协程并没有增加线程数量，只是在线程的基础之上通过分时复用的方式运行多个协程，而且协程的切换在用户态完成，切换的代价比线程从用户态到内核态的代价小很多。
### &emsp;&emsp;在有大量IO操作业务的情况下，我们采用协程替换线程，可以到达很好的效果，一是降低了系统内存，二是减少了系统切换开销，因此系统的性能也会提升。
### 在协程中尽量不要调用阻塞IO的方法，比如打印，读取文件，Socket接口等，除非改为异步调用的方式，并且协程只有在IO密集型的任务中才会发挥作用。
### &emsp;&emsp;协程只有和异步IO结合起来才能发挥出最大的威力。
#
# <font color=yellow size=5>select、poll 和 epoll 之间的区别</font>
## 1、select：时间复杂度 O(n)

### &emsp;&emsp;select 仅仅知道有 I/O 事件发生，但并不知道是哪几个流，所以只能无差别轮询所有流，找出能读出数据或者写入数据的流，并对其进行操作。所以 select 具有 O(n) 的无差别轮询复杂度，同时处理的流越多，无差别轮询时间就越长。

## 2、poll：时间复杂度 O(n)

### &emsp;&emsp;poll 本质上和 select 没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个 fd 对应的设备状态， 但是它没有最大连接数的限制，原因是它是基于链表来存储的。

## 3、epoll：时间复杂度 O(1)

### &emsp;&emsp;epoll 可以理解为 event poll，不同于忙轮询和无差别轮询，epoll 会把哪个流发生了怎样的 I/O 事件通知我们。 所以说 epoll 实际上是事件驱动（每个事件关联上 fd）的。
	
#
# <font color=yellow size=5>IO的五种方式</font>
- ### 程序直接控制
- ### 中断
- ### DMA
- ### 外围处理机
- ### 通道
	


